package bytes

import (
	"encoding/binary"
	"testing"

	"github.com/gnabgib/gnablib-go/encoding/hex"
)

func TestAddEq16BE(t *testing.T) {
	sum := make([]byte, bytes16)
	sumExpect := make([]byte, bytes16)
	b := make([]byte, bytes16)
	var carry byte
	for _, rec := range uint16AddEqTests {
		binary.BigEndian.PutUint16(sumExpect, rec.sumExpect)

		binary.BigEndian.PutUint16(sum, rec.a)
		binary.BigEndian.PutUint16(b, rec.b)
		carry = addEq16BE(sum, b, rec.carry)
		sumEqualAndCarry(t, uint32(rec.a), uint32(rec.b), sumExpect, sum, rec.carryExpect, carry)

		//Test commutative
		binary.BigEndian.PutUint16(sum, rec.b)
		binary.BigEndian.PutUint16(b, rec.a)
		carry = addEq16BE(sum, b, rec.carry)
		sumEqualAndCarry(t, uint32(rec.b), uint32(rec.a), sumExpect, sum, rec.carryExpect, carry)
	}

	var hexTests = []struct {
		a, b        string
		carry       byte
		sumExpect   uint16
		carryExpect byte
	}{
		{"FFFF", "", 0, 0xffff, 0},
		{"FFFF", "00", 0, 0xffff, 0},
		{"FFFF", "0000", 0, 0xffff, 0},
		{"FFFF", "000001", 0, 0xffff, 0}, //Last byte of b ignored
		{"FFFF", "01", 0, 0, 1},
		{"FFFF", "0001", 0, 0, 1}, //65535+256=65791
		{"FFFF", "0100", 0, 0x00ff, 1},
	}
	for _, rec := range hexTests {
		binary.BigEndian.PutUint16(sumExpect, rec.sumExpect)

		padLE(sum, hex.ToBytesFast(rec.a), bytes16)
		//Note we want a fresh b2 because we want to test irregular length byte slices
		b2 := hex.ToBytesFast(rec.b)
		carry = addEq16BE(sum, b2, rec.carry)
		sumEqualAndCarryHex(t, rec.a, rec.b, sumExpect, sum, rec.carryExpect, carry)

		//Test commutative, although sum must always be the right size, so use padLE
		padBE(sum, hex.ToBytesFast(rec.b), bytes16)
		b2 = hex.ToBytesFast(rec.a)
		carry = addEq16BE(sum, b2, rec.carry)
		sumEqualAndCarryHex(t, rec.b, rec.a, sumExpect, sum, rec.carryExpect, carry)
	}
}

func TestAddEq32BE(t *testing.T) {
	sum := make([]byte, bytes32)
	sumExpect := make([]byte, bytes32)
	b := make([]byte, bytes32)
	var carry byte
	for _, rec := range uint32AddEqTests {
		binary.BigEndian.PutUint32(sumExpect, rec.sumExpect)

		binary.BigEndian.PutUint32(sum, rec.a)
		binary.BigEndian.PutUint32(b, rec.b)
		carry = addEq32BE(sum, b, rec.carry)
		sumEqualAndCarry(t, rec.a, rec.b, sumExpect, sum, rec.carryExpect, carry)

		//Test commutative
		binary.BigEndian.PutUint32(sum, rec.b)
		binary.BigEndian.PutUint32(b, rec.a)
		carry = addEq32BE(sum, b, rec.carry)
		sumEqualAndCarry(t, rec.b, rec.a, sumExpect, sum, rec.carryExpect, carry)
	}

	var hexTests = []struct {
		a, b        string
		carry       byte
		sumExpect   uint32
		carryExpect byte
	}{
		{"FFFFFFFF", "", 0, 0xffffffff, 0},
		{"FFFFFFFF", "00", 0, 0xffffffff, 0},
		{"FFFFFFFF", "0000", 0, 0xffffffff, 0},
		{"FFFFFFFF", "000000", 0, 0xffffffff, 0},
		{"FFFFFFFF", "00000000", 0, 0xffffffff, 0},
		{"FFFFFFFF", "0000000001", 0, 0xffffffff, 0}, //Last byte of b ignored
		{"FFFFFFFF", "01", 0, 0, 1},
		{"FFFFFFFF", "0001", 0, 0, 1},
		{"FFFFFFFF", "000001", 0, 0, 1},
		{"FFFFFFFF", "00000001", 0, 0, 1},
		{"FFFFFFFF", "0100", 0, 0x000000ff, 1},
	}
	for _, rec := range hexTests {
		binary.BigEndian.PutUint32(sumExpect, rec.sumExpect)

		padBE(sum, hex.ToBytesFast(rec.a), bytes32)
		//Note we want a fresh b2 because we want to test irregular length byte slices
		b2 := hex.ToBytesFast(rec.b)
		carry = addEq32BE(sum, b2, rec.carry)
		sumEqualAndCarryHex(t, rec.a, rec.b, sumExpect, sum, rec.carryExpect, carry)

		//Test commutative, although sum must always be the right size, so use padLE
		padBE(sum, hex.ToBytesFast(rec.b), bytes32)
		b2 = hex.ToBytesFast(rec.a)
		carry = addEq32BE(sum, b2, rec.carry)
		sumEqualAndCarryHex(t, rec.b, rec.a, sumExpect, sum, rec.carryExpect, carry)
	}
}

func TestAdd16BE(t *testing.T) {
	sum := make([]byte, bytes16)
	a := make([]byte, bytes16)
	b := make([]byte, bytes16)
	sumExpect := make([]byte, bytes16)
	var carry byte

	for _, rec := range uint16Tests {
		binary.BigEndian.PutUint16(a, rec.a)
		binary.BigEndian.PutUint16(b, rec.b)
		binary.BigEndian.PutUint16(sumExpect, rec.sum)

		carry, _ = Add16BE(sum, a, b)
		bytesEqualAndCarry(t, a, b, sumExpect, sum, rec.carry, carry)

		//Test commutative
		carry, _ = Add16BE(sum, b, a)
		bytesEqualAndCarry(t, b, a, sumExpect, sum, rec.carry, carry)
	}

	var hexTests = []struct {
		a, b  string
		sum   uint16
		carry byte
	}{
		{"", "", 0, 0},
		{"00", "", 0, 0},
		{"00", "00", 0, 0},
		{"0000", "", 0, 0},
		{"0000", "00", 0, 0},
		{"0000", "0000", 0, 0},
		{"01", "", 1, 0},
		{"0102", "", 0x0102, 0},
		{"0102", "01", 0x0103, 0},
		{"FF01", "01", 0xff02, 0},
		{"FFFF", "01", 0, 1},
		{"FFFF", "FFFF", 0xfffe, 1}, //Nax sum
	}
	for _, rec := range hexTests {
		binary.BigEndian.PutUint16(sumExpect, rec.sum)
		a2 := hex.ToBytesFast(rec.a)
		b2 := hex.ToBytesFast(rec.b)

		carry, _ = Add16BE(sum, a2, b2)
		bytesEqualAndCarry(t, a2, b2, sumExpect, sum, rec.carry, carry)

		//Test commutative
		carry, _ = Add16BE(sum, b2, a2)
		bytesEqualAndCarry(t, b2, a2, sumExpect, sum, rec.carry, carry)
	}
}

func TestAddBE32(t *testing.T) {
	sumExpect := make([]byte, bytes32)

	sum := make([]byte, bytes32)
	a := make([]byte, bytes32)
	b := make([]byte, bytes32)
	var carry byte

	for _, rec := range uint32Tests {
		binary.BigEndian.PutUint32(a, rec.a)
		binary.BigEndian.PutUint32(b, rec.b)
		binary.BigEndian.PutUint32(sumExpect, rec.sum)

		carry, _ = Add32BE(sum, a, b)
		bytesEqualAndCarry(t, a, b, sumExpect, sum, rec.carry, carry)

		//Test commutative
		carry, _ = Add32BE(sum, b, a)
		bytesEqualAndCarry(t, b, a, sumExpect, sum, rec.carry, carry)
	}

	var hexTests = []struct {
		a, b  string
		sum   uint32
		carry byte
	}{
		{"", "", 0, 0},
		{"00", "", 0, 0},
		{"00", "00", 0, 0},
		{"0000", "", 0, 0},
		{"0000", "00", 0, 0},
		{"0000", "0000", 0, 0},
		{"01", "", 1, 0},
		{"0102", "", 0x0102, 0},
		{"0102", "01", 0x0103, 0},
		{"FF01", "01", 0xff02, 0},
		{"FFFF", "01", 0x010000, 0},
		{"FFFF", "FFFF", 0x1fffe, 0},

		{"FFFFFFFF", "", 0xffffffff, 0},
		{"FFFFFFFF", "00", 0xffffffff, 0},
		{"FFFFFFFF", "0000", 0xffffffff, 0},
		{"FFFFFFFF", "000000", 0xffffffff, 0},
		{"FFFFFFFF", "00000000", 0xffffffff, 0},
		{"FFFFFFFF", "0000000001", 0xffffffff, 0}, //Last byte of b ignored
		{"FFFFFFFF", "01", 0, 1},
		{"FFFFFFFF", "0001", 0, 1},
		{"FFFFFFFF", "000001", 0, 1},
		{"FFFFFFFF", "00000001", 0, 1},
		{"FFFFFFFF", "0100", 0x000000ff, 1},
		{"FFFFFFFF", "010000", 0x0000ffff, 1},
		{"FFFFFFFF", "01000000", 0x00ffffff, 1},
		{"FFFFFFFF", "FFFFFFFF", 0xfffffffe, 1}, //Nax sum
	}
	for _, rec := range hexTests {
		binary.BigEndian.PutUint32(sumExpect, rec.sum)
		a2 := hex.ToBytesFast(rec.a)
		b2 := hex.ToBytesFast(rec.b)

		carry, _ = Add32BE(sum, a2, b2)
		sumEqualAndCarryHex(t, rec.a, rec.b, sumExpect, sum, rec.carry, carry)

		//Test commutative
		carry, _ = Add32BE(sum, b2, a2)
		sumEqualAndCarryHex(t, rec.b, rec.a, sumExpect, sum, rec.carry, carry)
	}
}

// 128,256,512 use similar processing

func TestAdd128BE(t *testing.T) {
	sum := make([]byte, bytes128)
	var carry byte

	var hexTests = []struct {
		a, b, sum string
		carry     byte
	}{
		{
			"",
			"",
			"00000000000000000000000000000000",
			0},
		{
			"00",
			"",
			"00000000000000000000000000000000",
			0},
		{
			"01",
			"",
			"00000000000000000000000000000001",
			0},
		{
			"0001",
			"",
			"00000000000000000000000000000001",
			0},
		{
			"0100",
			"",
			"00000000000000000000000000000100",
			0},
		{
			"000102",
			"",
			"00000000000000000000000000000102",
			0},
		{
			"00010203",
			"",
			"00000000000000000000000000010203",
			0},
		{
			"0001020304",
			"",
			"00000000000000000000000001020304",
			0},
		{
			"000102030405",
			"",
			"00000000000000000000000102030405",
			0},
		{
			"00010203040506",
			"",
			"00000000000000000000010203040506",
			0},
		{
			"0001020304050607",
			"",
			"00000000000000000001020304050607",
			0},
		{
			"00010203040506070809",
			"",
			"00000000000000010203040506070809",
			0},
		{
			"000102030405060708090A0B",
			"",
			"00000000000102030405060708090A0B",
			0},
		{
			"000102030405060708090A0B0C0D",
			"",
			"0000000102030405060708090A0B0C0D",
			0},
		{
			"000102030405060708090A0B0C0D0E",
			"",
			"00000102030405060708090A0B0C0D0E",
			0},
		{
			"000102030405060708090A0B0C0D0E0F",
			"",
			"000102030405060708090A0B0C0D0E0F",
			0},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			0},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"01",
			"00000000000000000000000000000000",
			1},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"0001",
			"00000000000000000000000000000000",
			1},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"000001",
			"00000000000000000000000000000000",
			1},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE",
			1},
		{
			"FF0000000000000000000000000000FF",
			"00000000000000000000000000000001",
			"FF000000000000000000000000000100",
			0},
		{
			"FF0000000000000000000000000000FF",
			"01000000000000000000000000000000",
			"000000000000000000000000000000FF",
			1},
		{
			"FF00FF00FF00FF00FF00FF00FF00FF00",
			"00FF00FF00FF00FF00FF00FF00FF00FF",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			0},
		{
			"FF00FF00FF00FF00FF00FF00FF00FF00",
			"01FF00FF00FF00FF00FF00FF00FF00FF",
			"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			1},
		{
			"FF00FF00FF00FF00FF00FF00FF00FF00",
			"00FF00FF00FF00FF01FF00FF00FF00FF",
			"000000000000000000FFFFFFFFFFFFFF",
			1},
		{
			"FF00FF00FF00FF00FF00FF00FF00FF01",
			"00FF00FF00FF00FF00FF00FF00FF00FF",
			"00000000000000000000000000000000",
			1},
	}
	for _, rec := range hexTests {
		a := hex.ToBytesFast(rec.a)
		b := hex.ToBytesFast(rec.b)
		carry, _ = Add128BE(sum, a, b)
		bytesEqualAndCarryHex(t, rec.a, rec.b, rec.sum, sum, rec.carry, carry)

		//Test commutative
		carry, _ = Add128BE(sum, b, a)
		bytesEqualAndCarryHex(t, rec.b, rec.a, rec.sum, sum, rec.carry, carry)
	}
}

func TestAdd256BE(t *testing.T) {
	sum := make([]byte, bytes256)
	var carry byte

	var hexTests = []struct {
		a, b, sum string
		carry     byte
	}{
		{
			"",
			"",
			"0000000000000000000000000000000000000000000000000000000000000000",
			0},
		{
			"03",
			"05",
			"0000000000000000000000000000000000000000000000000000000000000008",
			0},
	}
	for _, rec := range hexTests {
		a := hex.ToBytesFast(rec.a)
		b := hex.ToBytesFast(rec.b)
		carry, _ = Add256BE(sum, a, b)
		bytesEqualAndCarryHex(t, rec.a, rec.b, rec.sum, sum, rec.carry, carry)

		//Test commutative
		carry, _ = Add256BE(sum, b, a)
		bytesEqualAndCarryHex(t, rec.b, rec.a, rec.sum, sum, rec.carry, carry)
	}
}

func TestAdd512BE(t *testing.T) {
	sum := make([]byte, bytes512)
	var carry byte

	var hexTests = []struct {
		a, b, sum string
		carry     byte
	}{
		{
			"",
			"",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			0},
		{
			"01",
			"",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001", 0},
		{
			"00",
			"01",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001", 0},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"01",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", 1},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", 1},
		{ //Same as +1
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", 1},
		{
			"0123456789ABCDEF",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000123456789ABCDEF",
			"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002468ACF13579BDE", 0},
		{
			"0123456789ABCDEF",
			"0123456789ABCDEF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			"0123456789ABCDEF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000123456789ABCDEF", 0},
		{
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
			"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100", 0},
		{
			"01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			"FF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", 1},
		{
			"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00",
			"00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", 0},
		{
			"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00",
			"01FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF",
			"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", 1},
		{
			"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF01",
			"00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", 1},
		{
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE", 1},
		{
			"03030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303",
			"05050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505",
			"08080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808", 0},
		{
			"03030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303",
			"050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505",
			"03080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808", 0},
		{
			"03030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303",
			"050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505",
			"03030303080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808", 0},
		{
			"03030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303",
			"0505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505",
			"03030303030808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808", 0},
		{
			"03030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303",
			"0505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505",
			"03030303030303030808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808", 0},
		{
			"0100",
			"22",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000122", 0},
		{
			"0001",
			"22",
			"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000023", 0},
	}
	for _, rec := range hexTests {
		a := hex.ToBytesFast(rec.a)
		b := hex.ToBytesFast(rec.b)
		carry, _ = Add512BE(sum, a, b)
		bytesEqualAndCarryHex(t, rec.a, rec.b, rec.sum, sum, rec.carry, carry)

		//Test commutative
		carry, _ = Add512BE(sum, b, a)
		bytesEqualAndCarryHex(t, rec.b, rec.a, rec.sum, sum, rec.carry, carry)
	}
}

// func TestAddBE512(t *testing.T) {
// 	var hexTests = []struct {
// 		a, b, sum string
// 		carry     byte
// 	}{
// 		{
// 			"",
// 			"",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000000", 0},
// 		{
// 			"01",
// 			"",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000001", 0},
// 		{
// 			"00",
// 			"01",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000001", 0},
// 		{
// 			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
// 			"01",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000000", 1},
// 		{ //Same as +1
// 			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000001",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000000", 1},
// 		{
// 			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
// 			"0100000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000000",
// 			"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", 1},
// 		{
// 			"0123456789abcdef",
// 			"0123456789abcdef000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000000",
// 			"0123456789abcdef000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000123456789abcdef", 0},
// 		{
// 			"0123456789abcdef",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000123456789abcdef",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"00000000000000000000000000000000000000000000000002468ACF13579BDE", 0},
// 		{
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000001",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"00000000000000000000000000000000000000000000000000000000000000FF",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000100", 0},
// 		{
// 			"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00" +
// 				"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00",
// 			"00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF" +
// 				"00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF",
// 			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", 0},
// 		{
// 			"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00" +
// 				"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF01",
// 			"00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF" +
// 				"00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000000", 1},
// 		{
// 			"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00" +
// 				"FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00",
// 			"01FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF" +
// 				"00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF",
// 			"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", 1},
// 		{
// 			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
// 			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
// 			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
// 				"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE", 1},
// 		{
// 			"0303030303030303030303030303030303030303030303030303030303030303" +
// 				"0303030303030303030303030303030303030303030303030303030303030303",
// 			"0505050505050505050505050505050505050505050505050505050505050505" +
// 				"0505050505050505050505050505050505050505050505050505050505050505",
// 			"0808080808080808080808080808080808080808080808080808080808080808" +
// 				"0808080808080808080808080808080808080808080808080808080808080808", 0},
// 		{
// 			"0303030303030303030303030303030303030303030303030303030303030303" +
// 				"0303030303030303030303030303030303030303030303030303030303030303",
// 			"05050505050505050505050505050505050505050505050505050505050505" +
// 				"0505050505050505050505050505050505050505050505050505050505050505",
// 			"0308080808080808080808080808080808080808080808080808080808080808" +
// 				"0808080808080808080808080808080808080808080808080808080808080808", 0},
// 		{"0100", "22",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000122", 0},
// 		{"0001", "22",
// 			"0000000000000000000000000000000000000000000000000000000000000000" +
// 				"0000000000000000000000000000000000000000000000000000000000000023", 0},
// 	}
// 	for _, rec := range hexTests {
// 		a := hex.ToBytesFast(rec.a)
// 		b := hex.ToBytesFast(rec.b)
// 		expectSum := hex.ToBytesFast(rec.sum)
// 		sum, carry := Add512BE(a, b)
// 		bytesEqualAndCarry(t, a, b, expectSum, sum, rec.carry, carry)
// 	}
// }
