// Copyright 2023 gnabgib
// This Source Code Form is subject to the terms of the Mozilla Public License v2.0

//go:build ignore
// +build ignore

// Generates whirlpool_tables.go
// `go run make_tables.go`

package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"go/format"
	"io"
	"log"
	"math/bits"
	"os"

	"github.com/gnabgib/gnablib-go/encoding/hex"
)

const (
	rounds = 10
	gfPoly = 0x11d //GF(2^8) polynomial=x8+x4+x3+x2+1
	sBox   = "" +
		"\x18\x23\xc6\xe8\x87\xb8\x01\x4f\x36\xa6\xd2\xf5\x79\x6f\x91\x52" +
		"\x60\xbc\x9b\x8e\xa3\x0c\x7b\x35\x1d\xe0\xd7\xc2\x2e\x4b\xfe\x57" +
		"\x15\x77\x37\xe5\x9f\xf0\x4a\xda\x58\xc9\x29\x0a\xb1\xa0\x6b\x85" +
		"\xbd\x5d\x10\xf4\xcb\x3e\x05\x67\xe4\x27\x41\x8b\xa7\x7d\x95\xd8" +
		//
		"\xfb\xee\x7c\x66\xdd\x17\x47\x9e\xca\x2d\xbf\x07\xad\x5a\x83\x33" +
		"\x63\x02\xaa\x71\xc8\x19\x49\xd9\xf2\xe3\x5b\x88\x9a\x26\x32\xb0" +
		"\xe9\x0f\xd5\x80\xbe\xcd\x34\x48\xff\x7a\x90\x5f\x20\x68\x1a\xae" +
		"\xb4\x54\x93\x22\x64\xf1\x73\x12\x40\x08\xc3\xec\xdb\xa1\x8d\x3d" +
		//
		"\x97\x00\xcf\x2b\x76\x82\xd6\x1b\xb5\xaf\x6a\x50\x45\xf3\x30\xef" +
		"\x3f\x55\xa2\xea\x65\xba\x2f\xc0\xde\x1c\xfd\x4d\x92\x75\x06\x8a" +
		"\xb2\xe6\x0e\x1f\x62\xd4\xa8\x96\xf9\xc5\x25\x59\x84\x72\x39\x4c" +
		"\x5e\x78\x38\x8c\xd1\xa5\xe2\x61\xb3\x21\x9c\x1e\x43\xc7\xfc\x04" +
		//
		"\x51\x99\x6d\x0d\xfa\xdf\x7e\x24\x3b\xab\xce\x11\x8f\x4e\xb7\xeb" +
		"\x3c\x81\x94\xf7\xb9\x13\x2c\xd3\xe7\x6e\xc4\x03\x56\x44\x7f\xa9" +
		"\x2a\xbb\xc1\x53\xdc\x0b\x9d\x6c\x31\x74\xf6\x46\xac\x89\x14\xe1" +
		"\x16\x3a\x69\x09\x70\xb6\xd0\xed\xcc\x42\x98\xa4\x28\x5c\xf8\x86" // substitutionBox
)

var header = []byte(`// Copyright 2023 gnabgib
// This Source Code Form is subject to the terms of the Mozilla Public License v2.0

// Code generated by go run make_tables.go. DO NOT EDIT.

package whirlpool

`)

var (
	rc = [rounds]uint64{}  // roundConstants
	ct = [8 * 256]uint64{} // circulantTable
)

func main() {
	//Zero pad to 16 digits, the uppercase hex version of a value:
	//fmt.Println(strings.ToUpper(fmt.Sprintf("%016x",circulantTable[q])))

	buildCirculantTable()
	buildRoundConstants()

	buf := bytes.NewBuffer(header)
	fmt.Fprintf(buf,"const rounds=%d\n\n",rounds)
	//Originally used getConst, which creates a string constant of each byte,
	// however the runtime penalty of string->[]byte->uint64 for access was too
	// high.  Possibly because ct is 2Kib in size
	genVar(buf, "rc", rc[:])
	genVar(buf, "ct", ct[:])

	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile("whirlpool_tables.go", out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

func genConst(w io.Writer, name string, data []uint64) {
	fmt.Fprintf(w, "const %s =\"\"+\n", name)
	for i, v := range data {
		if i > 0 {
			if i%2 == 0 {
				fmt.Fprint(w, "+\n")
			} else {
				fmt.Fprint(w, "+")
			}
		}
		if i%16 == 0 {
			fmt.Fprintf(w, "//%d\n", i)
		}

		fmt.Fprint(w, "\"")
		writeU64LE(w, v)
		fmt.Fprint(w, "\"")
	}
	fmt.Fprint(w, "\n\n")
}

func genVar(w io.Writer, name string, data []uint64) {
	fmt.Fprintf(w, "var %s =[...]uint64{\n", name)
	for i, v := range data {
		if i > 0 {
			if i%4 == 0 {
				fmt.Fprint(w, "\n")
			}
		}
		if i%16 == 0 {
			fmt.Fprintf(w, "//%d\n", i)
		}

		fmt.Fprintf(w, "0x%016x,", v)
	}
	fmt.Fprint(w, "}\n\n")
}

func writeU64LE(w io.Writer, v uint64) {
	b := make([]byte, 8)
	binary.LittleEndian.PutUint64(b, v)
	h := hex.FromBytes(b)
	for i := 0; i < 16; i += 2 {
		fmt.Fprint(w, "\\x"+h[i:i+2])
	}
}

func buildCirculantTable() {
	for x := 0; x < 256; x++ {
		v1 := uint64(sBox[x])
		v2 := v1 << 1
		if v2 >= 0x100 {
			v2 ^= gfPoly
		}
		v4 := v2 << 1
		if v4 >= 0x100 {
			v4 ^= gfPoly
		}
		v5 := v4 ^ v1
		v8 := v4 << 1
		if v8 >= 0x100 {
			v8 ^= gfPoly
		}
		v9 := v8 ^ v1
		ct[x] = (v1 << 56) | (v1 << 48) |
			(v4 << 40) | (v1 << 32) |
			(v8 << 24) | (v5 << 16) |
			(v2 << 8) | v9
		for t := 1; t < 8; t++ {
			ct[(t<<8)|x] = bits.RotateLeft64(ct[((t-1)<<8)|x], -8)
		}
	}
}

func buildRoundConstants() {
	for r := 0; r < rounds; r++ {
		r8 := r << 3
		rc[r] = (ct[r8] & 0xff00000000000000) ^
			(ct[(1<<8)|(r8+1)] & 0x00ff000000000000) ^
			(ct[(2<<8)|(r8+2)] & 0x0000ff0000000000) ^
			(ct[(3<<8)|(r8+3)] & 0x000000ff00000000) ^
			(ct[(4<<8)|(r8+4)] & 0x00000000ff000000) ^
			(ct[(5<<8)|(r8+5)] & 0x0000000000ff0000) ^
			(ct[(6<<8)|(r8+6)] & 0x000000000000ff00) ^
			(ct[(7<<8)|(r8+7)] & 0x00000000000000ff)
	}
}
